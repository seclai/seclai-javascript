/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/agents/runs/{run_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get an agent run
         * @description Fetch the latest snapshot for an agent run created by `POST /agents/{agent_id}/runs` or `POST /agents/{agent_id}/runs/stream`.
         *
         *     The response includes `status`, `error_count`, and `output` once the run completes. Use `include_step_outputs=true` to include per-step outputs, timing, durations, and credits.
         *
         *     Auth & scoping:
         *     - Requires `X-API-Key`. You can only access runs belonging to your account.
         */
        get: operations["get_agent_run_api_agents_runs__run_id__get"];
        put?: never;
        post?: never;
        /**
         * Cancel an agent run
         * @description Cancel a running agent run.
         *
         *     If the run is already in a terminal state (`completed` or `failed`), cancellation will be rejected.
         *
         *     Auth & scoping:
         *     - Requires `X-API-Key`. You can only cancel runs belonging to your account.
         */
        delete: operations["delete_agent_run_api_agents_runs__run_id__delete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/agents/{agent_id}/runs": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List agent runs
         * @description List runs for a specific agent (most recent first), with pagination.
         *
         *     Typical use cases:
         *     - Build a run history UI for an agent.
         *     - Debug recent executions and inspect terminal statuses.
         *
         *     Notes:
         *     - This endpoint returns a summary list. Fetch full details with `GET /agents/runs/{run_id}`.
         *
         *     Auth & scoping:
         *     - Requires `X-API-Key`. You can only list runs for agents in your account.
         */
        get: operations["list_agent_runs_api_agents__agent_id__runs_get"];
        put?: never;
        /**
         * Run an agent
         * @description Start an agent run.
         *
         *     An *agent* is an automated workflow that can monitor content from your sources, process it with AI, and trigger actions. This endpoint creates a new run and returns a `run_id` you can poll to retrieve status and output.
         *
         *     When to use:
         *     - Use this endpoint for request/response style integrations where polling is acceptable.
         *     - Use `POST /agents/{agent_id}/runs/stream` if you need real-time progress via SSE.
         *
         *     Key fields:
         *     - `priority`: set true for latency-sensitive, user-facing work.
         *     - `metadata`: a JSON object that becomes available to agent steps for string substitution.
         *
         *     After starting:
         *     - Poll `GET /agents/runs/{run_id}` until `status` is `completed` or `failed`.
         *     - Use `include_step_outputs=true` to include per-step outputs, timing, and credits.
         *
         *     Auth & scoping:
         *     - Requires `X-API-Key`. All resources are scoped to the API key's account.
         */
        post: operations["run_agent_api_agents__agent_id__runs_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/agents/{agent_id}/runs/stream": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Run an agent (stream events)
         * @description Start a **priority** agent run and stream run events using Server-Sent Events (SSE).
         *
         *     This is the best option for interactive UIs where you want progress updates as the run executes.
         *
         *     How it works:
         *     - The first `init` event contains an `AgentRunResponse` snapshot, including the `run_id`.
         *     - Subsequent events are forwarded from the run event stream (status changes, step events, etc).
         *     - The final `done` event contains the terminal snapshot (including `output` and `credits` when available).
         *
         *     Client guidance:
         *     - Keep the connection open and handle keepalive comments.
         *     - On `timeout` or `error`, the payload includes `run_id` so clients can resume by polling `GET /agents/runs/{run_id}`.
         *
         *     Auth & scoping:
         *     - Requires `X-API-Key`. All resources are scoped to the API key's account.
         */
        post: operations["run_streaming_agent_api_agents__agent_id__runs_stream_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/contents/{source_connection_content_version}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get content details
         * @description Get detailed information about a specific content item (a `SourceConnectionContentVersion`).
         *
         *     This is useful when you want to:
         *     - Inspect the extracted text for debugging or review.
         *     - Display content details in a UI.
         *
         *     Text range:
         *     - `start` and `end` control the character range returned in `text_content` so clients can page through large documents.
         *
         *     Auth & scoping:
         *     - Requires `X-API-Key`. You can only access content belonging to your account.
         */
        get: operations["get_content_detail_api_contents__source_connection_content_version__get"];
        put?: never;
        post?: never;
        /**
         * Delete content
         * @description Delete a content item (a `SourceConnectionContentVersion`).
         *
         *     Use this to remove an uploaded or indexed item from your account. Deleting content can affect agents and knowledge base workflows that reference this item.
         *
         *     Auth & scoping:
         *     - Requires `X-API-Key`. You can only delete content belonging to your account.
         */
        delete: operations["delete_content_api_contents__source_connection_content_version__delete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/contents/{source_connection_content_version}/embeddings": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List content embeddings
         * @description List the embeddings (chunk vectors) for a content item, with pagination.
         *
         *     Embeddings are used for semantic search and retrieval in knowledge base workflows. This endpoint is primarily useful for debugging chunking, indexing, and vector contents.
         *
         *     Auth & scoping:
         *     - Requires `X-API-Key`. You can only access embeddings for content belonging to your account.
         */
        get: operations["list_content_embeddings_api_contents__source_connection_content_version__embeddings_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/contents/{source_connection_content_version}/upload": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Replace a content version with a new upload
         * @description Upload a new file and replace the content backing an existing `SourceConnectionContentVersion`.
         *
         *     This behaves like a source file upload, but it targets an existing content version ID. This is useful when you want to correct or update an uploaded document while keeping references stable.
         *
         *     **Maximum file size:** 209715200 bytes.
         *
         *     **Supported MIME types:**
         *     - `application/epub+zip`
         *     - `application/json`
         *     - `application/msword`
         *     - `application/pdf`
         *     - `application/vnd.ms-excel`
         *     - `application/vnd.ms-outlook`
         *     - `application/vnd.ms-powerpoint`
         *     - `application/vnd.openxmlformats-officedocument.presentationml.presentation`
         *     - `application/vnd.openxmlformats-officedocument.spreadsheetml.sheet`
         *     - `application/vnd.openxmlformats-officedocument.wordprocessingml.document`
         *     - `application/xml`
         *     - `application/zip`
         *     - `audio/flac`
         *     - `audio/mp4`
         *     - `audio/mpeg`
         *     - `audio/ogg`
         *     - `audio/wav`
         *     - `image/bmp`
         *     - `image/gif`
         *     - `image/jpeg`
         *     - `image/png`
         *     - `image/tiff`
         *     - `image/webp`
         *     - `text/csv`
         *     - `text/html`
         *     - `text/markdown`
         *     - `text/plain`
         *     - `text/x-markdown`
         *     - `text/xml`
         *     - `video/mp4`
         *     - `video/quicktime`
         *     - `video/x-msvideo`
         *
         *     Notes:
         *     - If the uploaded file's content type is `application/octet-stream`, the server attempts to infer the type from the file extension.
         *     - Use `metadata` to attach an arbitrary JSON object of metadata (for example `metadata={"category":"docs"}`).
         *     - `title` is a convenience field and is merged into the metadata as `metadata.title` (it does not override an existing `metadata.title`).
         *     - For backwards compatibility, you can also pass form fields named `metadata_<key>` (for example `metadata_author=...`). These override keys from `metadata`.
         *
         *     Auth & scoping:
         *     - Requires `X-API-Key`. You can only replace content belonging to your account.
         */
        post: operations["upload_file_to_content_api_contents__source_connection_content_version__upload_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sources/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List sources
         * @description List content sources for your account.
         *
         *     A *source* is where Seclai pulls or receives content from (for example RSS feeds, websites, file uploads, or custom indexes). Sources are the inputs that power your agents and knowledge base workflows.
         *
         *     Parameters:
         *     - Pagination: `page` and `limit`.
         *     - Sorting: `sort` (created_at/updated_at/name) and `order` (asc/desc).
         *
         *     Auth & scoping:
         *     - Requires `X-API-Key`. Results are scoped to the API key's account.
         *     - The optional `account_id` query param is only allowed when it matches the API key's account.
         */
        get: operations["list_sources_api_sources__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sources/{source_connection_id}/upload": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Upload a file to a content source
         * @description Upload a file to a content source.
         *
         *     **Maximum file size:** 209715200 bytes.
         *
         *     **Supported MIME types:**
         *     - `application/epub+zip`
         *     - `application/json`
         *     - `application/msword`
         *     - `application/pdf`
         *     - `application/vnd.ms-excel`
         *     - `application/vnd.ms-outlook`
         *     - `application/vnd.ms-powerpoint`
         *     - `application/vnd.openxmlformats-officedocument.presentationml.presentation`
         *     - `application/vnd.openxmlformats-officedocument.spreadsheetml.sheet`
         *     - `application/vnd.openxmlformats-officedocument.wordprocessingml.document`
         *     - `application/xml`
         *     - `application/zip`
         *     - `audio/flac`
         *     - `audio/mp4`
         *     - `audio/mpeg`
         *     - `audio/ogg`
         *     - `audio/wav`
         *     - `image/bmp`
         *     - `image/gif`
         *     - `image/jpeg`
         *     - `image/png`
         *     - `image/tiff`
         *     - `image/webp`
         *     - `text/csv`
         *     - `text/html`
         *     - `text/markdown`
         *     - `text/plain`
         *     - `text/x-markdown`
         *     - `text/xml`
         *     - `video/mp4`
         *     - `video/quicktime`
         *     - `video/x-msvideo`
         *
         *     Notes:
         *     - If the uploaded file's content type is `application/octet-stream`, the server attempts to infer the type from the file extension.
         *     - Use `metadata` to attach an arbitrary JSON object of metadata (for example `metadata={"author":"Ada","category":"docs"}`).
         *     - `title` is a convenience field and is merged into the metadata as `metadata.title` (it does not override an existing `metadata.title`).
         *     - For backwards compatibility, you can also pass form fields named `metadata_<key>` (for example `metadata_author=...`). These override keys from `metadata`.
         *
         *     Response:
         *     - `status` is `uploaded` for a new upload, or `duplicate` when the same file already exists for this source.
         */
        post: operations["upload_file_to_source_api_sources__source_connection_id__upload_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        /** AgentRunAttemptResponse */
        AgentRunAttemptResponse: {
            /**
             * Duration
             * @description Duration of the attempt in seconds.
             */
            duration: number | null;
            /**
             * Ended At
             * @description Timestamp when the attempt ended.
             */
            ended_at: string | null;
            /**
             * Error
             * @description Error message if the attempt failed.
             */
            error: string | null;
            /**
             * Started At
             * @description Timestamp when the attempt started.
             */
            started_at: string | null;
            /** @description Status of the agent run attempt. */
            status: components["schemas"]["PendingProcessingCompletedFailedStatus"];
        };
        /** AgentRunRequest */
        AgentRunRequest: {
            /**
             * Input
             * @description Input to provide to the agent upon running for agents with dynamic triggers.
             */
            input: string | null;
            /**
             * Metadata
             * @description Metadata to make available for string substitution expressions in agent tasks.
             */
            metadata: {
                [key: string]: components["schemas"]["JsonValue"];
            } | null;
            /**
             * Priority
             * @description If true, the agent run will be treated as priority execution.
             * @default false
             */
            priority: boolean;
        };
        /** AgentRunResponse */
        AgentRunResponse: {
            /**
             * Attempts
             * @description List of attempts made for this agent run.
             */
            attempts: components["schemas"]["AgentRunAttemptResponse"][];
            /**
             * Credits
             * @description Credits consumed by the agent run, if applicable.
             */
            credits: number | null;
            /**
             * Error Count
             * @description Number of errors encountered during the run.
             */
            error_count: number;
            /**
             * Input
             * @description Input provided to the agent for this run.
             */
            input: string | null;
            /**
             * Output
             * @description Output produced by the agent run.
             */
            output: string | null;
            /**
             * Priority
             * @description Indicates if the run was treated as a priority execution.
             */
            priority: boolean;
            /**
             * Run Id
             * @description Unique identifier for the agent run.
             */
            run_id: string;
            /** @description Current status of the agent run. */
            status: components["schemas"]["PendingProcessingCompletedFailedStatus"];
            /**
             * Steps
             * @description Step outputs and per-step timing/credits. Only included when requested.
             */
            steps?: components["schemas"]["AgentRunStepResponse"][] | null;
        };
        /** AgentRunStepResponse */
        AgentRunStepResponse: {
            /**
             * Agent Step Id
             * @description Agent step identifier.
             */
            agent_step_id: string;
            /**
             * Credits Used
             * @description Credits consumed by the step attempt, if applicable.
             */
            credits_used: number;
            /**
             * Duration Seconds
             * @description Duration of the step attempt in seconds.
             */
            duration_seconds: number | null;
            /**
             * Ended At
             * @description Timestamp when the step attempt ended.
             */
            ended_at: string | null;
            /**
             * Output
             * @description Output produced by the step, if any.
             */
            output: string | null;
            /**
             * Output Content Type
             * @description Content type of the step output, if any.
             */
            output_content_type: string | null;
            /**
             * Started At
             * @description Timestamp when the step attempt started.
             */
            started_at: string | null;
            /** @description Status of the step run. */
            status: components["schemas"]["PendingProcessingCompletedFailedStatus"];
            /**
             * Step Type
             * @description Type of the agent step.
             */
            step_type: string;
        };
        /** AgentRunStreamRequest */
        AgentRunStreamRequest: {
            /**
             * Input
             * @description Input to provide to the agent upon running for agents with dynamic triggers.
             */
            input: string | null;
            /**
             * Metadata
             * @description Metadata to make available for string substitution expressions in agent tasks.
             */
            metadata: {
                [key: string]: components["schemas"]["JsonValue"];
            } | null;
        };
        /** Body_upload_file_to_content_api_contents__source_connection_content_version__upload_post */
        Body_upload_file_to_content_api_contents__source_connection_content_version__upload_post: {
            /**
             * File
             * Format: binary
             * @description File to upload
             */
            file: string;
            /**
             * Metadata
             * @description Optional JSON object string of metadata. Example: `{"category":"docs","author":"Ada"}`. `title` will be merged into this dictionary as `metadata.title` if it is not already present.
             */
            metadata?: string | null;
            /**
             * Title
             * @description Optional title for the content
             */
            title?: string;
        };
        /** Body_upload_file_to_source_api_sources__source_connection_id__upload_post */
        Body_upload_file_to_source_api_sources__source_connection_id__upload_post: {
            /**
             * File
             * Format: binary
             * @description File to upload
             */
            file: string;
            /**
             * Metadata
             * @description Optional JSON object string of metadata. Example: `{"author":"Ada","category":"docs"}`. `title` will be merged into this dictionary as `metadata.title` if it is not already present.
             */
            metadata?: string | null;
            /**
             * Title
             * @description Optional title for the content
             */
            title?: string;
        };
        /**
         * ContentEmbeddingResponse
         * @description Response model for content embedding.
         */
        ContentEmbeddingResponse: {
            /** Batch Duration */
            batch_duration: number;
            /** Batch Size */
            batch_size: number;
            /** Id */
            id: string;
            /** Text */
            text: string;
            /** Text End */
            text_end: number;
            /** Text Start */
            text_start: number;
            /** Vector */
            vector: number[];
        };
        /** HTTPValidationError */
        HTTPValidationError: {
            /** Detail */
            detail?: components["schemas"]["ValidationError"][];
        };
        JsonValue: unknown;
        /**
         * PaginationResponse
         * @description Pagination information.
         */
        PaginationResponse: {
            /** Has Next */
            has_next: boolean;
            /** Has Prev */
            has_prev: boolean;
            /** Limit */
            limit: number;
            /** Page */
            page: number;
            /** Pages */
            pages: number;
            /** Total */
            total: number;
        };
        /**
         * PendingProcessingCompletedFailedStatus
         * @enum {string}
         */
        PendingProcessingCompletedFailedStatus: "pending" | "processing" | "completed" | "failed";
        /**
         * SourceResponse
         * @description Response model for source data.
         */
        SourceResponse: {
            /**
             * Account Id
             * Format: uuid
             * @description Account ID associated with the source.
             */
            account_id: string;
            /**
             * Avg Episodes Per Month
             * @description Average number of episodes per month.
             */
            avg_episodes_per_month?: number | null;
            /**
             * Avg Words Per Episode
             * @description Average number of words per episode.
             */
            avg_words_per_episode?: number | null;
            /**
             * Chunk Language
             * @description Language used for chunking content.
             */
            chunk_language?: string | null;
            /**
             * Chunk Overlap
             * @description Chunk overlap for content processing.
             */
            chunk_overlap?: number | null;
            /**
             * Chunk Regex Separators
             * @description Indicates if chunk separators are regex patterns.
             */
            chunk_regex_separators?: boolean | null;
            /**
             * Chunk Separators
             * @description Chunk separators used for content processing.
             */
            chunk_separators?: string | null;
            /**
             * Chunk Size
             * @description Chunk size for content processing.
             */
            chunk_size?: number | null;
            /**
             * Content Count
             * @description Number of content items associated with the source connection.
             * @default 0
             */
            content_count: number;
            /**
             * Content Filter
             * @description Content filter for the source connection.
             */
            content_filter: string;
            /**
             * Created At
             * @description Timestamp when the source connection was created.
             */
            created_at: string;
            /**
             * Dimensions
             * @description Dimensions of the embedding model.
             */
            dimensions?: number | null;
            /**
             * Embedding Model
             * @description Embedding model used for the source connection.
             */
            embedding_model?: string | null;
            /**
             * Embedding Model Type
             * @description Type of the embedding model.
             */
            embedding_model_type?: string | null;
            /**
             * Has Historical Data
             * @description Indicates if the source connection has historical data.
             * @default false
             */
            has_historical_data: boolean;
            /**
             * Id
             * @description Unique identifier for the source connection.
             */
            id: string;
            /**
             * Name
             * @description Name of the source connection.
             */
            name: string;
            /**
             * Next Poll At
             * @description Timestamp for the next scheduled poll.
             */
            next_poll_at: string | null;
            /**
             * Polling
             * @description Polling configuration for the source connection.
             */
            polling: string | null;
            /**
             * Polling Action
             * @description Polling action for the source connection.
             */
            polling_action: string | null;
            /**
             * Polling Max Items
             * @description Maximum items to poll for the source connection.
             */
            polling_max_items: number | null;
            /**
             * Pulled At
             * @description Timestamp when content was last pulled.
             */
            pulled_at: string | null;
            /**
             * Readonly
             * @description Indicates if the source connection is read-only.
             * @default false
             */
            readonly: boolean;
            /**
             * Retention
             * @description Retention period for the source connection.
             */
            retention: number | null;
            /**
             * Source Type
             * @description Type of the source connection.
             */
            source_type: string;
            /**
             * Updated At
             * @description Timestamp when the source connection was last updated.
             */
            updated_at: string;
            /**
             * Url
             * @description URL of the source connection.
             */
            url: string | null;
        };
        /** ValidationError */
        ValidationError: {
            /** Location */
            loc: (string | number)[];
            /** Message */
            msg: string;
            /** Error Type */
            type: string;
        };
        /** AgentRunListResponse */
        routers__api__agents__AgentRunListResponse: {
            /**
             * Data
             * @description List of agent runs.
             */
            data: components["schemas"]["AgentRunResponse"][];
            pagination: components["schemas"]["PaginationResponse"];
        };
        /**
         * ContentDetailResponse
         * @description Response model for content detail.
         */
        routers__api__contents__ContentDetailResponse: {
            /**
             * Content Duration
             * @description Duration of the content in seconds.
             */
            content_duration: number | null;
            /**
             * Content Duration Display
             * @description Display string for content duration.
             */
            content_duration_display: string | null;
            /**
             * Content Status
             * @description Status of the content.
             */
            content_status: string;
            /**
             * Content Type
             * @description Type of the content.
             */
            content_type: string;
            /**
             * Content Type Display
             * @description Display name of the content type.
             */
            content_type_display: string;
            /**
             * Content Url
             * @description URL of the content.
             */
            content_url: string;
            /**
             * Content Word Count
             * @description Word count of the content.
             */
            content_word_count: number | null;
            /**
             * Description
             * @description Description of the content.
             */
            description: string | null;
            /**
             * Error
             * @description Error message, if any.
             */
            error: string | null;
            /**
             * Id
             * @description Unique identifier for the content version.
             */
            id: string;
            /**
             * Metadata
             * @description Metadata associated with the content.
             */
            metadata: {
                [key: string]: string;
            }[] | null;
            /**
             * Published At
             * @description Timestamp when the content was published.
             */
            published_at: string | null;
            /**
             * Pulled At
             * @description Timestamp when the content was pulled.
             */
            pulled_at: string;
            /**
             * Source Connection Content Version Id
             * @description ID of the source connection content version.
             */
            source_connection_content_version_id: string;
            /**
             * Source Connection Id
             * @description ID of the source connection.
             */
            source_connection_id: string;
            /**
             * Source Name
             * @description Name of the source.
             */
            source_name: string;
            /**
             * Source Type
             * @description Type of the source.
             */
            source_type: string;
            /**
             * Text Content
             * @description Text content.
             */
            text_content: string | null;
            /**
             * Text Content End
             * @description End position of the text content.
             */
            text_content_end: number;
            /**
             * Text Content Start
             * @description Start position of the text content.
             */
            text_content_start: number;
            /**
             * Text Content Total Length
             * @description Total length of the text content.
             */
            text_content_total_length: number;
            /**
             * Title
             * @description Title of the content.
             */
            title: string | null;
        };
        /**
         * ContentEmbeddingsListResponse
         * @description Response model for paginated content embeddings.
         */
        routers__api__contents__ContentEmbeddingsListResponse: {
            /** Data */
            data: components["schemas"]["ContentEmbeddingResponse"][];
            pagination: components["schemas"]["PaginationResponse"];
        };
        /**
         * FileUploadResponse
         * @description Response model for content file replacement upload.
         */
        routers__api__contents__FileUploadResponse: {
            /**
             * Content Version Id
             * @description ID of the content version being replaced
             */
            content_version_id: string | null;
            /**
             * Filename
             * @description Original filename
             */
            filename: string;
            /**
             * Source Connection Content Version Id
             * @description ID of the source connection content version
             */
            source_connection_content_version_id: string | null;
            /**
             * Status
             * @description Processing status
             */
            status: string;
        };
        /**
         * FileUploadResponse
         * @description Response model for file upload
         */
        routers__api__sources__FileUploadResponse: {
            /**
             * Content Version Id
             * @description ID of the created content version
             */
            content_version_id: string | null;
            /**
             * Filename
             * @description Original filename
             */
            filename: string;
            /**
             * Source Connection Content Version Id
             * @description ID of the duplicate source connection content version
             */
            source_connection_content_version_id: string | null;
            /**
             * Status
             * @description Processing status
             */
            status: string;
        };
        /**
         * SourceListResponse
         * @description Response model for paginated source list
         */
        routers__api__sources__SourceListResponse: {
            /** Data */
            data: components["schemas"]["SourceResponse"][];
            pagination: components["schemas"]["PaginationResponse"];
        };
    };
    responses: never;
    parameters: never;
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    get_agent_run_api_agents_runs__run_id__get: {
        parameters: {
            query?: {
                /** @description If true, include per-step outputs with timing, durations, and credits. */
                include_step_outputs?: boolean;
            };
            header?: never;
            path: {
                run_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AgentRunResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    delete_agent_run_api_agents_runs__run_id__delete: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                run_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AgentRunResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    list_agent_runs_api_agents__agent_id__runs_get: {
        parameters: {
            query?: {
                /** @description Page number */
                page?: number;
                /** @description Items per page */
                limit?: number;
            };
            header?: never;
            path: {
                agent_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["routers__api__agents__AgentRunListResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    run_agent_api_agents__agent_id__runs_post: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                agent_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["AgentRunRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AgentRunResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    run_streaming_agent_api_agents__agent_id__runs_stream_post: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                agent_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["AgentRunStreamRequest"];
            };
        };
        responses: {
            /**
             * @description Streams agent run events via Server-Sent Events (SSE); run is always created as priority.
             *
             *     SSE events:
             *     - `event: init` — `data` is an `AgentRunResponse` snapshot (includes `run_id`).
             *     - `event: done` — `data` is the final `AgentRunResponse` snapshot (includes `output`, `credits`, etc).
             *     - Other events (e.g. `status`, step events) are forwarded from the run event stream.
             *     - On `timeout` / `error`, the payload includes `run_id` so clients can fetch status via `GET /api/agents/runs/{run_id}`.
             */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                    /**
                     * @example : keepalive
                     *
                     *     event: init
                     *     data: {"run_id":"...","status":"pending","error_count":0,"credits":0.0,"priority":true,"input":"...","output":null,"attempts":[]}
                     *
                     *     event: done
                     *     data: {"run_id":"...","status":"completed","error_count":0,"credits":0.0,"priority":true,"input":"...","output":"...","attempts":[]}
                     */
                    "text/event-stream": string;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_content_detail_api_contents__source_connection_content_version__get: {
        parameters: {
            query?: {
                start?: number;
                end?: number;
            };
            header?: never;
            path: {
                source_connection_content_version: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["routers__api__contents__ContentDetailResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    delete_content_api_contents__source_connection_content_version__delete: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                source_connection_content_version: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    list_content_embeddings_api_contents__source_connection_content_version__embeddings_get: {
        parameters: {
            query?: {
                page?: number;
                limit?: number;
            };
            header?: never;
            path: {
                source_connection_content_version: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["routers__api__contents__ContentEmbeddingsListResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    upload_file_to_content_api_contents__source_connection_content_version__upload_post: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                source_connection_content_version: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "multipart/form-data": components["schemas"]["Body_upload_file_to_content_api_contents__source_connection_content_version__upload_post"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["routers__api__contents__FileUploadResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    list_sources_api_sources__get: {
        parameters: {
            query?: {
                /** @description Page number */
                page?: number;
                /** @description Items per page */
                limit?: number;
                /** @description Sort field */
                sort?: string;
                /** @description Sort order */
                order?: string;
                /** @description List sources for the given account. Defaults to the api key's account. */
                account_id?: string | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["routers__api__sources__SourceListResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    upload_file_to_source_api_sources__source_connection_id__upload_post: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                source_connection_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "multipart/form-data": components["schemas"]["Body_upload_file_to_source_api_sources__source_connection_id__upload_post"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["routers__api__sources__FileUploadResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
}
